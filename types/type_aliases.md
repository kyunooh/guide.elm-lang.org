# 타입 별명\(Type Aliases\)

타입 별명은 그냥 여러분의 타입 어노테이션을 읽기 쉽게 만들어 준다고 생각하시면 되요.

여러분이 점점 더 복잡한 프로그램을 만들다 보면, 복잡한 데이터로 큰 작업들을 하게 되요. 예를 들어, 강아지를 위한 트위터를 만든 뒤 유저의 정보를  보여줘야 할지도 모르죠. 이때 유저의 약력이 있는 지 없는 지 확인하려면 다음과 같이 작성하겠죠.

```elm
hasBio : { name : String, bio : String, pic : String } -> Bool
hasBio user =
  String.length user.bio > 0
```

위 타임 어노테이션은 굉장히 난잡해 보여요. 많은 정보를 담고 있지도 않은데 말이죠! 만약 10개의 필드가 있다고 상상해보세요. 또는 유저의 매개 변수를 사용해서 다시 유저를 결과로 준다고 생각해보세요.

이런 경우에 바로 타입 별명을 사용하면 되요.

```elm
type alias User =
  { name : String
  , bio : String
  , pic : String
  }
```

이 의미는 `User`가 나타날 때마다 해당 내용으로 바꿔쳐 진다는 거에요. 자 이제 `hasBio` 함수를 좀 더 멋지게 바꿔 볼게요.

```elm
hasBio : User -> Bool
hasBio user =
  String.length user.bio > 0
```

아까보다 더 보기 편하죠! 강조하고 싶은 점은 두 선언이 완벽하게 똑같다는 거에요. 별명을 만들면 훨씬 더 적은 키 스트로크로 같은 동작을 시킬 수 있는 거죠.

또 여러분이 약력을 추가 하고 싶으면 다음과 같이 하면 되요.

```elm
addBio : String -> User -> User
addBio bio user =
  { user | bio = bio }
```

만약 User 타입 별명이 없는 상태로 타입 어노테이션을 작성해봤다고 생각해보세요. 분명히 난잡하죠!

타입 별칭은 그냥 이쁘게 보이는 용도가 아니고, 좀 더 분명하게 생각할 수 있도록 도와줘요. Elm 프로그램을 작성할 때 함수를 작성하기 전에, 몇개의 타입 별명을 작성하는 게 가장 좋아요. 전반적으로 효율적이게 작업할 수 있게 되고, 어떤 종류의 데이터를 작업하고 있는지 명확해지죠. 또 다른 요소들을 추가 할때에도, 컴파일러가 기존 코드에 어떤 영향을 끼칠 지 감지 할 수 있어요. 제 생각엔 Elm으로 작성하는 분들 대부분이 이런 방식으로 작업할거라고 생각해요.

> **더 알아보기:** 여러분이 레코드를 위한 타입 별명을 만드실 때, 레코드 생성자 또한 만들어져요. 그렇기 때문에 User 타입 별칭은 아래와 같이 생성되요.
>
> ```elm
> User : String -> String -> String -> User
> ```
>
> 매개 변수들은 별명을 선언할 때와 같은 순서로 정렬되어요. 때때론 이것을 사용할 때도 있어요.



